---
title: "Rapport de Synthèse Écologique"
author: "Nom de l'Observateur"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  officedown::rdocx_document:
    reference_docx: "../style/word_styles_references.dotm"
params:
  photo_base_path: "G:/Drive partagés/BIODIV/1_CLIENTS/AGENCE_MTDA/2025/39_PG_BV_LEZ_EEE_2025/CARTO/DCIM/"

---

```{r}
library(sf)
library(tidyverse)
library(officedown)
library(flextable)
library(magick)

gpkg_path <-  normalizePath(file.path(params$photo_base_path,"../", "Donnees.gpkg"))
cat("Chemin construit :\n", gpkg_path, "\n")
cat("Le fichier existe ? ", file.exists(gpkg_path), "\n")


layers_info <- st_layers(gpkg_path)
print(layers_info)


releves <- st_read(dsn = gpkg_path, layer = "Releve_Phyto")
flore <- st_read(dsn = gpkg_path, layer = "Flore")
habitats <- st_read(dsn = gpkg_path, layer = "Habitat_P")
typologie <- st_read(dsn = gpkg_path, layer = "Typologie")
photos <- st_read(dsn = gpkg_path, layer = "photos") %>% 
  st_drop_geometry() # Supprimer la colonne de géométrie inutile


photos_agg <- photos %>%
  rename(uuid = Reference) %>% # Renommer pour la jointure
  group_by(uuid) %>%
  summarise(
    chemins_photos = list(Photo), # Agréger les chemins dans une liste
    commentaires_photos = list(Nom) # Agréger aussi les commentaires
  )

typologie <- st_read(gpkg_path, layer = "Typologie") %>%
  mutate(fid = as.character(row_number()))

releves_final <- releves %>%
  left_join(photos_agg, by = "uuid")

habitats_final <- habitats %>%
  left_join(photos_agg, by = "uuid")%>%
  left_join(typologie, by = c("Nom" = "fid"),suffix = c("", "_T"))

flore_final <- flore %>%
  left_join(photos_agg, by = "uuid")

# Filtrer la flore appartenant à un relevé et la joindre
flore_releves <- flore_final %>%
  filter(!is.na(Releve)) %>%
  select(Releve, Nom, Releve_Strate, Releve_Recouvrement)

```

# Bloc de configuration initial (chunk 'setup')
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Fonction d'aide pour traiter et intégrer les images
process_and_embed_image <- function(relative_path, base_path, caption = "", dpi = 300) {
  # Supprimer le double "DCIM/"
  relative_path <- sub("^DCIM/", "", relative_path)
  full_path <- file.path(base_path, relative_path)

  if (!file.exists(full_path)) {
    cat(paste("⚠️ Fichier introuvable :", full_path, "\n"))
    return()
  }

  temp_dir <- "output/temp_images"
  if (!dir.exists(temp_dir)) {
    dir.create(temp_dir, recursive = TRUE)
  }

  temp_image_path <- file.path(temp_dir, basename(relative_path))

  tryCatch({
    cat("✔️ Image détectée :", full_path, "\n")
    img <- image_read(full_path)
    img_compressed <- image_convert(img, format = 'jpeg')  # plus de dpi ici
    image_write(img_compressed, path = temp_image_path)    # ni ici
    print(knitr::include_graphics(temp_image_path))
  }, error = function(e) {
    cat(paste("❌ Erreur lors du traitement de l'image :", full_path, "\n", e$message, "\n"))
  })
}

```
# Début de la section des relevés
# Le chunk suivant utilise results='asis' pour générer du contenu dynamique

```{r releves_loop, results='asis'}
# Boucle sur chaque relevé dans la table releves_final
for (i in 1:nrow(releves_final)) {
  # Extraire les données du relevé courant
  releve_courant <- releves_final[i, ]
  
  # Générer un titre de section pour le relevé
  cat(paste("\n## Relevé :", releve_courant$Nom, "\n"))
  
  # --- Tableau des métadonnées du relevé ---
  # Sélectionner et préparer les données pour le tableau
  meta_data <- releve_courant %>%
    as.data.frame() %>%
    select(Nom, Date, Observateur, Habitat, Surface, Altitude, Pente, Exposition, Commentaire) %>%
    mutate(across(everything(), as.character)) %>%
    pivot_longer(cols = everything(), names_to = "Paramètre", values_to = "Valeur")
    
  # Créer le flextable
  ft_meta <- flextable(meta_data) %>%
    set_header_labels(Paramètre = "Données du relevé", Valeur = "Information") %>%
    autofit() %>%
    theme_booktabs() %>%
    width(j = 1, width = 2) %>%
    width(j = 2, width = 4)
  
  # Afficher le tableau
  ft_meta
  cat("\n")

  # --- Tableau de la liste d'espèces ---
  # Filtrer la flore pour ce relevé spécifique
  especes_du_releve <- flore_releves %>%
    filter(Releve == releve_courant$Nom) %>%
    select(`Nom Latin` = Nom, Strate = Releve_Strate, Recouvrement = Releve_Recouvrement)

  if (nrow(especes_du_releve) > 0) {
    cat("\n### Espèces observées dans le relevé\n")
    ft_especes <- flextable(especes_du_releve) %>%
      autofit() %>%
      theme_booktabs()
    ft_especes
    cat("\n")
  }

  # --- Photos associées au relevé ---
  if (!is.null(releve_courant$chemins_photos[])) {
    cat("\n### Photographies du relevé\n")
    # Boucle sur chaque photo associée
    for (j in 1:length(releve_courant$chemins_photos[])) {
      path <- releve_courant$chemins_photos[][j]
      caption <- releve_courant$commentaires_photos[][j]
      process_and_embed_image(path, base_path = params$photo_base_path, caption = caption)
      cat("\n")
    }
  }
  
  # Ajouter un saut de page après chaque relevé pour une meilleure lisibilité
  cat("\\newpage\n")
}

```

### 3.3 Section 2 : Synthèse Automatisée des Habitats

La structure de cette section est volontairement similaire à la précédente, démontrant la modularité et la réutilisabilité de l'approche. Une boucle parcourt la table `habitats_final` et génère pour chaque habitat une fiche descriptive avec ses données et ses photos.


# Début de la section des habitats
```{r habitats_loop, results='asis'}

# Boucle sur chaque habitat
for (i in 1:nrow(habitats_final)) {
  habitat_courant <- habitats_final[i, ]
  
  # Titre de la section
  cat(paste("\n## Habitat :", habitat_courant$Nom, "\n"))
  
  # --- Tableau des données de l'habitat ---
  habitat_data <- habitat_courant %>%
    as.data.frame() %>%
    select(Nom, Date, Observateur, Conservation, Enjeu, Menace, Commentaire) %>%
    mutate(across(everything(), as.character)) %>%  # homogénéisation des types
    pivot_longer(cols = everything(), names_to = "Paramètre", values_to = "Valeur")

  ft_habitat <- flextable(habitat_data) %>%
    set_header_labels(Paramètre = "Caractéristique de l'habitat", Valeur = "Description") %>%
    autofit() %>%
    theme_booktabs()
    
  ft_habitat
  cat("\n")

  # --- Photos associées à l'habitat ---
  if (!is.null(habitat_courant$chemins_photos[])) {
    cat("\n### Photographies de l'habitat\n")
    for (j in 1:length(habitat_courant$chemins_photos[])) {
      path <- habitat_courant$chemins_photos[][j]
      caption <- habitat_courant$commentaires_photos[][j]
      process_and_embed_image(path, base_path = params$photo_base_path, caption = caption)
      cat("\n")
    }
  }
  cat("\\newpage\n")
}
```

### 3.4 Section 3 : Synthèse Automatisée de la Flore

Cette section adopte une logique légèrement différente. L'objectif est de créer une fiche par espèce, regroupant toutes les photos de cette espèce, qu'elles proviennent d'observations indépendantes, de relevés ou d'habitats.

# Début de la section flore
```{r flore_loop, results='asis'}
# Liste des espèces uniques avec des photos associées
especes_uniques <- flore_final %>%
  filter(!sapply(chemins_photos, is.null)) %>%
  distinct(Nom, .keep_all = TRUE) %>%
  arrange(Nom)

# Boucle sur chaque espèce unique
for (i in 1:nrow(especes_uniques)) {
  espece_courante_nom <- especes_uniques$Nom[i]
  
  # Vérifier qu'on a bien un nom valide
  if (is.na(espece_courante_nom) || espece_courante_nom == "") next

  # Titre de la section pour l'espèce
  cat(paste0("\n## Espèce : *", espece_courante_nom, "*\n"))
  
  # Filtrer les observations de cette espèce avec photos
  photos_espece <- flore_final %>%
    filter(Nom == espece_courante_nom, !sapply(chemins_photos, is.null))
  
  # Boucle sur les observations
  for (k in 1:nrow(photos_espece)) {
    obs_courante <- photos_espece[k, ]
    chemins <- obs_courante$chemins_photos[[1]]
    commentaires <- obs_courante$commentaires_photos[[1]]

    if (!is.null(chemins) && length(chemins) > 0) {
      for (j in 1:length(chemins)) {
        process_and_embed_image(chemins[j], base_path = params$photo_base_path, caption = commentaires[j])
        cat("\n")
      }
    }
  }
}
```

## Partie IV : Personnalisation Avancée et Finition Professionnelle

Cette dernière partie fournit les éléments qui transforment un rapport fonctionnel en un document professionnel et soigné. Elle donne les clés pour prendre le contrôle total de l'apparence de la sortie finale.

### 4.1 Maîtriser le style Word avec un `reference_docx`

Le secret d'un document Word bien formaté réside dans le fichier `reference_docx` spécifié dans l'en-tête YAML. Ce fichier est un document Word standard dans lequel les styles ont été prédéfinis.

*   **Étape 1 : Créer le document de base.** La manière la plus simple est de générer une première version du rapport sans `reference_docx`. R Markdown créera un document Word avec les styles par défaut.
*   **Étape 2 : Modifier les styles de paragraphe.** Ouvrez ce document dans Word. Allez dans l'onglet "Accueil", faites un clic droit sur un style (par exemple, "Titre 1", "Titre 2", "Normal") et sélectionnez "Modifier". Vous pouvez alors changer la police, la taille, la couleur, l'espacement, etc. Ces modifications seront appliquées à tous les titres de ce niveau dans le document final.
*   **Étape 3 : Créer des styles de tableau personnalisés.** C'est la clé pour des tableaux professionnels. Sélectionnez un tableau dans le document Word généré. Un onglet contextuel "Création de tableau" apparaît. Dans le groupe "Styles de tableau", cliquez sur la flèche du bas, puis sur "Nouveau style de tableau". Donnez-lui un nom explicite, par exemple "ThemeTable". Définissez ses propriétés : formatage de la ligne d'en-tête, lignes à bandes, bordures, marges des cellules. Enregistrez ce style.[8]
*   **Étape 4 : Appliquer les styles depuis R.** Sauvegardez ce document Word modifié (par exemple, dans `templates/word_template.docx`). Le paquet `flextable` peut alors être instruit d'utiliser ces styles. Bien que `officedown` tente de faire correspondre les thèmes, le contrôle le plus explicite est obtenu en utilisant des fonctions de `flextable` pour appliquer un style nommé. Par exemple, la fonction `theme_booktabs()` utilisée dans le code ci-dessus crée un tableau propre et lisible qui s'adaptera bien aux styles de paragraphe du document de référence.

### 4.2 Le flux de travail du traitement d'images en détail

La fonction d'assistance `process_and_embed_image` utilise plusieurs fonctions clés du paquet `magick`.[10, 11]

*   `image_read(path)` : Lit une image depuis un chemin de fichier. `magick` peut gérer des dizaines de formats différents.
*   `image_info(img)` : Renvoie un data frame contenant les métadonnées de l'image, comme ses dimensions, son format et sa résolution d'origine. Utile pour le débogage.
*   `image_convert(format = 'jpeg', dpi = 300)` : C'est la commande principale. Elle convertit l'image au format JPEG (généralement plus compact pour les photographies) et, surtout, elle ré-échantillonne les pixels de l'image pour qu'elle corresponde à une résolution de 300 points par pouce (dpi). C'est ce qui permet de contrôler la qualité et le poids du fichier final.
*   `image_write(path = temp_path)` : Écrit l'image traitée dans le dossier temporaire.

L'utilisation d'un dossier temporaire pour les images compressées est une bonne pratique qui préserve l'intégrité des données brutes originales.

### 4.3 Assurer le succès à long terme : Maintenance et extension

Pour garantir que ce flux de travail reste fonctionnel et utile à l'avenir, quelques considérations supplémentaires sont importantes.

*   **Gestion des dépendances** : Les paquets R évoluent. Pour s'assurer que le script fonctionnera encore dans plusieurs années, l'utilisation du paquet `renv` est fortement recommandée. `renv` crée une bibliothèque de paquets spécifique au projet, "gelant" les versions des paquets utilisés. Cela garantit une parfaite reproductibilité à long terme.
*   **Gestion des erreurs** : Les boucles peuvent être fragiles. Que se passe-t-il si un chemin de photo est incorrect ou si un fichier image est corrompu? L'utilisation de `tryCatch()` autour des opérations critiques (comme le traitement d'images) permet au script de continuer son exécution même en cas d'erreur sur un élément, en imprimant simplement un message d'avertissement. La fonction d'aide fournie intègre déjà ce mécanisme.
*   **Améliorations futures** : Ce flux de travail est une base solide qui peut être étendue. On pourrait par exemple y ajouter :
    *   Une carte de localisation de tous les points d'observation en début de rapport, générée avec `ggplot2` et `sf`.
    *   Le calcul automatique d'indices de diversité (par exemple, Shannon, Simpson) pour chaque relevé phytosociologique.
    *   La création de tableaux croisés dynamiques (par exemple, présence/absence d'espèces par habitat).

### 4.4 Le script complet et annoté

Le document qui suit présente l'intégralité du fichier `.Rmd` final, avec des commentaires détaillés expliquant chaque étape. Il sert de référence consolidée et de point de départ pour toute adaptation future.

(Note : Le script complet est la somme des blocs de code présentés dans la Partie III, encapsulés dans un seul fichier `.Rmd` avec l'en-tête YAML approprié.)

## Conclusion

Ce rapport a détaillé une méthode complète et reproductible pour automatiser la génération de rapports écologiques à partir de données de terrain stockées dans un format GeoPackage. En combinant la puissance de R Markdown avec un ensemble d'outils spécialisés (`sf`, `tidyverse`, `officedown`, `flextable`, `magick`), il est possible de transformer un processus manuel et fastidieux en un flux de travail automatisé, fiable et professionnel.

L'approche présentée met l'accent sur la reproductibilité, la modularité et la qualité du document final. L'utilisation de boucles et de fonctions d'assistance permet de s'adapter à des jeux de données variables, tandis que l'intégration avec les styles Word via `officedown` et `flextable` garantit une finition soignée et personnalisable. Le traitement d'images par `magick` répond à une contrainte technique précise de gestion de la taille des fichiers.

En adoptant ce type de flux de travail, les écologues et les scientifiques peuvent consacrer plus de temps à l'analyse et à l'interprétation des données, et moins de temps à la mise en forme des rapports, tout en augmentant de manière significative la qualité et la fiabilité de leurs livrables.