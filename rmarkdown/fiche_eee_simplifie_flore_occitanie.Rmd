---
title: "Fiches espèces EEE – Bassin versant du Lez"
author: "Augustin Soulard"
date: "`r Sys.Date()`"
output:
  word_document:
    reference_docx: word_styles_references.docx
---

Pour l'instant il reste tout à faire. J'ai juste repris le code des grosses fiches.
Peut-être ajouter la zone d'étude et faire en sorte que la carte zoom sur la zone d'étude. Il faut donc modifier la fonction de génération de cartes.
-----------------------------------------------------------------------

# Préparation
```{r setup, include=FALSE}
# Chargement des bibliothèques nécessaires. Si vous ne les avez pas,
# pensez à les installer avec install.packages() au préalable.
library(officer)
library(flextable)
library(dplyr)
library(tools)
library(caulisroot)
library(tibble)
library(magick)
library(stringr)
library(sf)

# Connexion à la base de données de l'infini
con = copo()

# Charger le tableau de référence
vw_fiche_eee_flore_occitanie <- dbGetQuery(con, "SELECT * FROM statuts.vw_fiche_eee_flore_occitanie")


#############################
# Choix des espèces d’intérêt
#############################
cd_nom_to_sheet = c(92572,117860,116485,83938,86167,106571,117860,84173,80824)


# Filtrer les espèces à mettre en fiche
vw_fiche_eee_flore_occitanie = vw_fiche_eee_flore_occitanie %>% filter(cd_nom %in% cd_nom_to_sheet)


######################
# Préparation des cartes
######################
donnees_brut_atlas = read_sf("G:/Drive partagés/BIODIV/1_CLIENTS/AGENCE_MTDA/2025/39_PG_BV_LEZ_EEE_2025/CARTO/data_biblio/FloreBibliopoint.gpkg",layer = "flore_comb_ze_statuts")

# Garder un nomvalide par cdrefcalc en gardant celui avec la plus grande chaîne de caractère
donnees_brut_atlas <- donnees_brut_atlas %>%                  
  group_by(cdrefcalc) %>%
  mutate(
    nomvalide_std = {
      v <- nomvalide
      v <- v[!is.na(v)]
      if (length(v) == 0) NA_character_ else
        # plus long d'abord, puis ordre alpha pour départager les ex-aequo
        v[order(-str_length(v), tolower(v))][1]
    }
  ) %>%
  ungroup() %>%
  mutate(nomvalide = nomvalide_std) %>%
  select(-nomvalide_std) %>% filter(cdrefcalc %in% cd_nom_to_sheet)

### Mise en conformité des noms scientifiques
donnees_brut_atlas$cdrefcalc = as.integer(donnees_brut_atlas$cdrefcalc)

donnees_atlas_conforme <- donnees_brut_atlas %>%
  left_join(vw_fiche_eee_flore_occitanie %>% select(cd_nom, nom_valide),
            by = c("cdrefcalc" = "cd_nom")) %>%
  mutate(nomvalide = coalesce(nom_valide, nomvalide)) %>%
  select(-nom_valide)




atlas_grid = crible_point_to_atlas_grid(donnees_atlas_conforme,
                           lb_nom = nomvalide,dissolve = FALSE,grid_size = 1000)

maps <- atlas_grid_map_for_spsheet(
  atlas_polys  = atlas_grid,
  lb_nom       = nomvalide,
    basemap      = "osm",
    fill         = "#701700",
    fill_alpha   = 0.5,
    border_col   = "#1F0600",
    border_size  = 0.5,
    basemap_alpha = 0.7,
  extent_source = "atlas",   # <- même bbox pour toutes les espèces
  export       = FALSE
)

### Floraison

    # Vecteur de correspondance des chiffres aux mois
      correspondance_mois <- c("Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre")
      
      # Fonction pour remplacer un chiffre par un mois
      remplacer_chiffre_par_mois <- function(chiffre) {
        chiffres <- as.numeric(unlist(strsplit(chiffre, "-")))
        mois <- paste(correspondance_mois[chiffres], collapse = "-")
        return(mois)
      }

# Appliquer la fonction sur la colonne du dataframe
      vw_fiche_eee_flore_occitanie$floraison <- sapply(vw_fiche_eee_flore_occitanie$floraison, remplacer_chiffre_par_mois)

# Création d'un document Word basé sur le modèle fourni. Le modèle
# "word_styles_references.docx" doit être présent dans le répertoire de travail.
doc <- read_docx(path = "word_styles_references.docx")

# Fonction utilitaire pour créer les fiches d'une espèce
for (i in seq_len(nrow(vw_fiche_eee_flore_occitanie))) {
  row <- vw_fiche_eee_flore_occitanie[i, ]

    # Ne garder que le texte avant la première virgule
    nom_vern <- sub(",.*", "", row$nom_vern)
    nom_scien = row$nom_valide
    
    taxref_status = case_when(
  row$fr == "J" ~ "Introduite envahissante",
    row$fr == "I" ~ "Introduite",
  row$fr == "P" ~ "Indigène",
  row$fr == "E" ~ "Endémique",
  TRUE ~ "-"  # Cas par défaut
)
    rmc = case_when(
    row$rmc_mediterraneen_hors_corse == "A" ~ "Gestion prioritaire si efficace/faisable (A)",
    row$rmc_mediterraneen_hors_corse == "B" ~ "Gestion conseillée si efficace/faisable (B)",
    row$rmc_mediterraneen_hors_corse == "C" ~ "Gestion pertinente si intérêt local démontré sur des sites/espèces à intérêt patrimonial ou sur des sites renaturés (C)",
    row$rmc_mediterraneen_hors_corse == "E" ~ "Surveillance/veille sur des espèces peu ou pas présentes (E) ",
    row$rmc_mediterraneen_hors_corse == "E+" ~ "Intervention urgente sur des espèces peu ou pas présentes (E+)",
  TRUE ~ "-"  # Cas par défaut
)
    rmc_code = ifelse(is.na(row$rmc_mediterraneen_hors_corse)||row$rmc_mediterraneen_hors_corse=="", "-", as.character( row$rmc_mediterraneen_hors_corse))
    	
  invmed = ifelse(is.na(row$invmed_categorie_occ), "-", as.character(row$invmed_categorie_occ))
    title_desc_gen = "Description"
    
    # On met un vide si pas de valeurs
    desc_gen = ifelse(is.na(row$dscpt_esp), "", row$dscpt_esp)
    dscpt_risque_eee  = ifelse(is.na(row$dscpt_risque_eee), "", row$dscpt_risque_eee)
    
    dscpt_habitats_esp  = ifelse(is.na(row$dscpt_habitats_esp), "", row$dscpt_habitats_esp)
    
    floraison = ifelse(is.na(row$floraison), "-", row$floraison)
   
    # AJout des risques à description générale
    desc_gen = paste0("Description générale : ",desc_gen,"  \n",
                      "Risques : ",dscpt_risque_eee,"  \n",
                      "Habitats : ",dscpt_habitats_esp,"  \n",
                      "Floraison : ",floraison)
    title_situation = "Situation au sein du bassin versant du Lez"
    
    # Legende de la photo
    legend = ifelse(is.na(row$legend), "", row$legend)
    legend = ifelse(is.na(row$date_photo),legend,paste0(legend," - ",format(row$date_photo, format = "%d/%m/%Y")))
    
#########################
# Définition des couleurs
#########################

row = row %>%
  mutate(
    fill_invmed = case_when(
      invmed_categorie_occ == "Majeure" ~ "#f0a0a2",
      invmed_categorie_occ =="Modérée" ~ "#f9f0ae",
      invmed_categorie_occ =="Emergente" ~ "#f7cbaf",
      invmed_categorie_occ =="Alerte" ~ "#ffbfee",
      invmed_categorie_occ =="Prévention" ~ "#cacaca",
      invmed_categorie_occ =="Non envahissante" ~ "#afe1f4",
      invmed_categorie_occ =="Non évaluée" ~ "#ffffff",
     TRUE       ~ "#ffffff"
    )
  )
    
#########################
# Lancement du flextable
#########################

df <- tibble(
  Groupe = c(nom_vern, title_desc_gen, desc_gen,title_situation, "Situation","Photo et carte","légendes photo et carte"),
  Detail = c(nom_scien, title_desc_gen, desc_gen,title_situation, "Situation","Photo et carte","légendes photo et carte"),
  taxref_status = c(taxref_status, title_desc_gen, desc_gen,title_situation, "Situation","Photo et carte","légendes photo et carte"),
  rmc    = c(rmc, title_desc_gen, desc_gen, title_situation, "Situation","Photo et carte","légendes photo et carte"),
  invmed = c(invmed, title_desc_gen, desc_gen,title_situation, "Situation","Photo et carte","légendes photo et carte")
)

ft <- flextable(df) |>
  merge_v(j = "Groupe") |>
  valign(j = "Groupe", valign = "center") |>
  align(j = c("Groupe","Detail","taxref_status","rmc","invmed"), align = "center",part="all") |>
  set_header_labels(Groupe = "Nom vernaculaire", Detail = "Nom scientifique",
                    taxref_status = "Taxref",
                    rmc    = "Rhône-Méditerranée-Corse",
                    invmed = "Invmed") |>
  add_header_row(values = c("Nom vernaculaire", "Nom scientifique", "Statuts"),
                 colwidths = c(1, 1, 3)) |>
  valign(part = "header", valign = "center") |>
  theme_booktabs() |>
  autofit()

# Préparation de Description générale
i_title <- which(df$Groupe == title_desc_gen & df$Detail == title_desc_gen)

# 2) fusion horizontale sur toute la ligne
ft <- merge_h_range(ft, i = i_title, j1 = 1, j2 = ncol(df), part = "body")

# (Optionnel) centrer et styliser la ligne fusionnée
ft <- bg(ft, i = i_title, j = 1, bg = "#C9D6F1", part = "all")
ft <- padding(ft, i = i_title, j = 1, padding = 6)

# Préparation de Situation vis-à-vis du projet
i_title <- which(df$Groupe == title_situation & df$Detail == title_situation)
# 2) fusion horizontale sur toute la ligne
ft <- merge_h_range(ft, i = i_title, j1 = 1, j2 = ncol(df), part = "body")
# (Optionnel) centrer et styliser la ligne fusionnée
ft <- bg(ft, i = i_title, j = 1, bg = "#C9D6F1", part = "body")
ft <- padding(ft, i = i_title, j = 1, padding = 6)

# Fusion des cases en une colonne
# Préparation de Situation vis-à-vis du projet
i_title <- which(df$Groupe == desc_gen & df$Detail == desc_gen)
# 2) fusion horizontale sur toute la ligne
ft <- merge_h_range(ft, i = i_title, j1 = 1, j2 = ncol(df), part = "body")

# Préparation de Situation vis-à-vis du projet
i_title <- which(df$Groupe == "Situation" & df$Detail == "Situation")
# 2) fusion horizontale sur toute la ligne
ft <- merge_h_range(ft, i = i_title, j1 = 1, j2 = ncol(df), part = "body")

## --- 1) En-tête : fusion verticale des colonnes 1 et 2
ft <- merge_v(ft, part = "header", j = c("Groupe", "Detail"))
ft <- align(ft, part = "header", j = c("Groupe","Detail"), align = "center")

## --- 2) Deux colonnes égales pour les 2 dernières lignes
i_2rows <- which(df$Groupe %in% c("Photo et carte", "légendes photo et carte") &
                 df$Detail %in% c("Photo et carte", "légendes photo et carte"))

# fusionner 3 colonnes à gauche et 2 à droite => 2 colonnes visuelles
ft <- merge_h_range(ft, i = i_2rows, j1 = 1, j2 = 3, part = "body")
ft <- merge_h_range(ft, i = i_2rows, j1 = 4, j2 = 5, part = "body")

# --- Styles des en-têtes (2 lignes du header)
ft <- bg(ft, part = "header", bg = "#C9D6F1")
ft <- bold(ft, part = "header", bold = TRUE)

## --- Styles des têtes de section dans le corps
i_desc_title <- which(df$Groupe == title_desc_gen & df$Detail == title_desc_gen)
i_situ_title <- which(df$Groupe == title_situation & df$Detail == title_situation)

# Comme les cellules sont fusionnées horizontalement, on cible 1:ncol(df)
ft <- bg(  ft, i = i_desc_title, j = 1:ncol(df), bg   = "#C9D6F1", part = "body")
ft <- bold(ft, i = i_desc_title, j = 1:ncol(df), bold = TRUE,       part = "body")

ft <- bg(  ft, i = i_situ_title, j = 1:ncol(df), bg   = "#C9D6F1", part = "body")
ft <- bold(ft, i = i_situ_title, j = 1:ncol(df), bold = TRUE,       part = "body")

# which(df$Groupe == title_desc_gen & df$Detail == title_desc_gen)
i_invmed = which(df$invmed == invmed)
ft <- bg(  ft, i = i_invmed, j = "invmed", bg   = row$fill_invmed, part = "body")

# équilibrer visuellement les largeurs (1:3 == 4:5)
ft <- width(ft, j = 1, width = 1.2)
ft <- width(ft, j = 2, width = 1.4)
ft <- width(ft, j = 3, width = 1.2)   # 1.2*3 = 3.6
ft <- width(ft, j = 4, width = 1.8)
ft <- width(ft, j = 5, width = 1.2)   # 1.8*2 = 3.6

# Fixer les largeurs
ft <- set_table_properties(ft, layout = "fixed")

# centrage des cellules visibles (la 1re de chaque bloc)
ft <- align(ft, i = i_2rows, j = c(1, 4), align = "center", part = "body")
ft <- valign(ft, i = i_2rows, j = c(1, 4), valign = "center", part = "body")

# (facultatif) renforcer la séparation verticale entre les 2 blocs
sep_bord <- fp_border(color = "#C9D6F1", width = 1)
ft <- vline(ft, i = i_2rows, j = 4, border = sep_bord, part = "body")

# sécuriser desc_general / desc_risque si tu les utilises plus bas
desc_general <- ifelse(is.na(row$dscpt_esp), "", row$dscpt_esp)
desc_risque  <- ifelse(is.na(row$dscpt_risque_eee), "", row$dscpt_risque_eee)

#################
# Photo et carte
#################

# Photo à gauche, carte à droite
i_photo <- which(df$Groupe == "Photo et carte" & df$Detail == "Photo et carte")
i_leg   <- which(df$Groupe == "légendes photo et carte" & df$Detail == "légendes photo et carte")

# Récupération/chargement de la photo (URL http(s) ou chemin local)
photo_url  <- row$path
photo_file <- ""
if (!is.na(photo_url) && nzchar(photo_url)) {
  if (grepl("^https?://", photo_url)) {
    ext <- tolower(gsub(".*\\.", ".", basename(photo_url)))
    temp_file <- tempfile(pattern = "photo_", fileext = ext)
    try({ download.file(photo_url, destfile = temp_file, mode = "wb", quiet = TRUE)
          photo_file <- temp_file }, silent = TRUE)
  } else if (file.exists(photo_url)) {
    photo_file <- photo_url
  }
}

# Gestion du ratio width/height

magick_img = image_read(photo_file)
info = image_info(magick_img)
witdth_img = 3.5
height_img = witdth_img * info$height/info$width
# Insérer les images directement dans les cellules fusionnées : j=1 (bloc gauche), j=4 (bloc droit)
# Photo (gauche)
if (nzchar(photo_file) && file.exists(photo_file)) {
  ft <- compose(ft, i = i_photo, j = 1,
                value = as_paragraph(as_image(photo_file, width = witdth_img, height = height_img)),
                part = "body")
} else {
  ft <- compose(ft, i = i_photo, j = 1,
                value = as_paragraph("Photo non disponible"),
                part = "body")
}

#####################
# Création des cartes
#####################

map_file = maps$plots[[ nom_scien ]]

if(!exists("map_file", where = globalenv())){
  # Carte (droite)
  map_file <- file.path("CARTO", paste0(row$cd_nom, ".jpg"))
  
  if (file.exists(map_file)) {
    ft <- compose(ft, i = i_photo, j = 4,
                  value = as_paragraph(as_image(map_file, width = 4,height = 3)),
                  part = "body")
  } else {
    ft <- compose(ft, i = i_photo, j = 4,
                  value = as_paragraph("Carte non disponible"),
                  part = "body")
  }
}else {
        tmpfile <- tempfile(fileext = ".png")
        ggsave(tmpfile, plot = map_file, width = 6, height = 5, dpi = 300)
        
        ft <- compose(ft, i = i_photo, j = 4,
                      value = as_paragraph(as_image(tmpfile, width = 3, height = 2.5)),
                      part = "body")
  }



# Hauteur de ligne suffisante pour loger les images
ft <- height(ft, i = i_photo, height = height_img*1.1, part = "body")

# Légendes dans la ligne suivante, colonne gauche/droite
carte_legend_text <- "Répartition du taxon dans le bassin versant du Lez – Données SILENE, Agence MTDA et BIODIV"

ft <- compose(ft, i = i_leg, j = 1, value = as_paragraph(legend), part = "body")
ft <- compose(ft, i = i_leg, j = 4, value = as_paragraph(carte_legend_text), part = "body")

# Centrage et petite taille de police pour la ligne légendes
ft <- fontsize(ft, i = i_leg, j = c(1, 4), size = 10, part = "body")

#########################
# Gestion des alignements
#########################

# Centrer TOUT le body et le header
ft <- align(ft, j = names(df), align = "center", part = "body")
ft <- align(ft, j = names(df), align = "center", part = "header")
ft <- valign(ft, j = names(df), valign = "center", part = "header")

# Exceptions : les 2 lignes "texte long" à gauche dans la 1re colonne

i_desc   <- which(df$Groupe == desc_gen       & df$Detail == desc_gen)
i_situ   <- which(df$Groupe == "Situation"    & df$Detail == "Situation")


ft <- align(ft, i = i_desc, j = 1, align = "left", part = "body")
ft <- align(ft, i = i_situ, j = 1, align = "left", part = "body")

lbl <- fp_text(bold = TRUE)  # style gras

ft <- compose(
  ft, i = i_desc, j = 1,
  value = as_paragraph(
    as_chunk("Description : ", props = lbl), as_chunk(desc_general), as_chunk("\n"),
    as_chunk("Risques : ", props = lbl),     as_chunk(dscpt_risque_eee), as_chunk("\n"),
    as_chunk("Habitats : ", props = lbl),    as_chunk(dscpt_habitats_esp), as_chunk("\n"),
    as_chunk("Floraison : ", props = lbl),   as_chunk(floraison)
  ),
  part = "body"
)

#########################
# Gestion du style global
#########################

# Style global : Calibri + bordures vert foncé
ft <- font(ft, part = "all", fontname = "Calibri")
# Italique pour le nom scientifique (toutes les lignes sans formule)
ft <- italic(ft, j = "Detail", part = "body", italic = TRUE)


#####################
# Gestion des bordures
#####################

# Bordures globales
bd <- fp_border(color = "#C9D6F1", width = 1)
ft <- border_remove(ft)
ft <- border_outer(ft, part = "all", border = bd)
ft <- hline(ft, border = bd, part = "all")  # pas de i/j => pas de formules
ft <- vline(ft, border = bd, part = "all")

# --- Style de bordure dédié
bord_titre <- fp_border(color = "#ffffff", width = 1)  # épais, vert foncé

# 1) En-têtes (les 2 lignes : "Nom vernaculaire", "Nom scientifique",
#    "Statuts", puis "Taxref", "Rhône-Méditerranée-Corse", "Invmed")
ft <- border(
  ft, part = "header", i = 1:2, j = 1:ncol(df),
  border.top = bord_titre, border.bottom = bord_titre,
  border.left = bord_titre, border.right = bord_titre
)

######################
# Affichage Rmarkdown
######################

ft

#############################
# Génération du document Word
#############################

doc <- body_add_flextable(doc, ft)

# (facultatif) les sections texte :
# doc <- body_add_par(doc, "", style = "Normal")
# doc <- body_add_par(doc, "Description générale", style = "heading 3")
# doc <- body_add_par(doc, desc_general, style = "Normal")
# doc <- body_add_par(doc, "", style = "Normal")
# doc <- body_add_par(doc, "Risques", style = "heading 3")
# doc <- body_add_par(doc, desc_risque, style = "Normal")
# doc <- body_add_par(doc, "", style = "Normal")
# doc <- body_add_par(doc, "Situation vis-à-vis du projet", style = "heading 3")
# doc <- body_add_par(doc, "", style = "Normal")
  # Ajout d'un saut de page sauf pour la dernière fiche
if (i < nrow(vw_fiche_eee_flore_occitanie)) doc <- body_add_break(doc)

}

# Export du document Word final. Il sera enregistré dans le dossier de travail
# sous le nom indiqué ci‑dessous.
dbDisconnect(con) 
print(doc, target = "fiches_eee_flore_occitanie_officer.docx")

```
